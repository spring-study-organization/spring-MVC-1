# 스프링 웹 MVC
<HR>

## 웹 서버, 웹 애플리케이션 서버

<img src="img/1-1.png">\

> 웹은 HTTP 프로토콜 기반으로 모든 통신이 일어난다.

### 모든 것이 HTTP 
HTTP 메시지에 모든 것을 전송

* HTML, TEXT
* IMAGE, 음성, 영상, 파일
* JSON, XML (API)
* 거의 모든 형태의 데이터 전송 가능
* 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용 지금은 HTTP 시대!

<img src="img/1-2.png">

> 정적 파일 전송을 위한 서버로 js,html,css 같은 파일 전송을 하는 서버 대표적인 서버로 `nignx`, `apache` 가 있다.

<img src="img/1-3.png">

> WAS는 앞선 웹서버의 상위호환격의 서버로 웹서버의 기능을 모두 포함하고 프로그램 코드를 실행해서 동적으로 동작이 가능하다.
> ex) 사용자의 이름을 가져오거나 사용자별로 다른 화면을 보여줌

<HR>

### 웹 서버, 웹 애플리케이션 서버(WAS) 차이

* 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직 + 웹 서버의 기능 포함
* 사실은 둘의 용어도 경계도 모호함
  * 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함
  * 웹 애플리케이션 서버도 웹 서버의 기능을 제공함
* 자바는 서블릿 컨테이너 기능을 제공하면 WAS
  * 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음
* WAS는 애플리케이션 코드를 실행하는데 더 특화

<HR>

### 웹 시스템 구성 - WAS, DB

<img src="img/1-4.png">

> 제일 간단한 구성 => WAS, 디비 조합으로 서버를 구성

<img src="img/1-5.png">

> 하지만, WAS가 모든 일을 담당하기 때문에 안정성이 떨어지는 단점이 존재한다.
> WAS가 장애나면 웹서버에 접근조차 안됨 => 오류화면 조차 볼 수가 없음.

<HR>

### 웹 시스템 구성 - WEB(서버), WAS, DB

<img src="img/1-6.png">

> 위의 문제를 해결하기 위해 보편적으로 구축하는 인프라 형태
> 정적 리소스 형태는 웹서버에게 위임하고 동적인 요청만 WAS가 받는 구조

<img src="img/1-7.png">

> 이런 형태로 인프라를 구축하면 효율적인 리소스 관리가 가능해짐
> 가령, 정적인 리소스가 많이 필요하면 웹서버를 늘리고/동적인 리소스가 많이 필요하면 WAS를 늘리면 된다.

<img src="img/1-8.png">

<HR>

## 서블릿

<img src="img/서블릿-1.png">

> 왼쪽 html 양식에 username, age를 입력하고 전송을 누르면 웹 브라우저가 오른쪽과 같이 HTTP 메시지를 생성하고 서버로 전송한다.

<img src="img/서블릿-2.png">

> 웹 브라우저가 보낸 메시지를 가지고 서버가 처리해야 하는 리스트는 왼쪽과 같다.
> 서버 TCP/IP 연결대기, 소켓 연결... HTTP 요청 메시지를 파싱해서 읽기...
> 이 많은 일중 정작 중요한 비즈니스 로직은 "데이터베이스에 저장 요청" 한가지 이다.
> 만약 서버를 직접 구현 해야 한다면 다른 일을 하느라 정작 중요한 비즈니스 로직에 집중하지 못하는 상황이 발생한다.  

<img src="img/서블릿-3.png">

> 이를 해결하기 위해 Servelt이 나온다. 
> 즉, 왼쪽의 리스트에서 비즈니스 로직을 제외한 모든 일을 대신 처리해주게 된다.

<img src="img/서블릿-4.png">

> HTTP에 대한 정보를 유용하게 사용하기 위한 서블릿 객체가 존재하며 
> 이곳의 HttpServletRequest, HttpServletResponse를 사용해서 http 요청과 응답에 대한 정보를 사용할 수 있게 된다.

<img src="img/서블릿-5.png">

> 웹 브라우저가 요청을 보내면 WAS 에서 Servlet이 해주는 일
>1. 브라우저가 보낸 HTTP 요청 메시지를 기반으로 request, response 객체를 만들어줌.
>2. 개발자가 만든 서블릿 객체를 실행.
>3. 1번에서 생성한 response 객체의 정보를 기반으로 HTTP 응답 메시지를 생성.
>4. 웹 브라우저에 생성한 응답 메시지 전달.

#### 서블릿 -HTTP 요청, 응답 흐름

* HTTP 요청시
  * WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출 
  * 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용 
  * 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력 
  * WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

### 서블릿 컨테이너

<img src="img/서블릿-6.png">

> WAS 내부에는 서블릿 컨테이너가 존재하여 개발자가 작성한 서블릿 관련 코드를 읽어서 서블릿 객체를 생성하고 관리해줌.

#### 서블릿, 서블릿 컨테이너

* 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함 
* 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리 
* 서블릿 객체는 **싱글톤**으로 관리
  * 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율
  * 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 
  * 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근 
  * **공유 변수 사용 주의** 
  * 서블릿 컨테이너 종료시 함께 종료
* JSP도 서블릿으로 변환 되어서 사용
* 동시 요청을 위한 멀티 쓰레드 처리 지원

> 위의 Request, Response 객체는 요청시 마다 정보가 다를것이므로 각 요청마다 새로 생성해서 사용한다.(싱글톤 X)
> 서블릿 객체만 재활용
> 싱글톤 객체이기 때문에 서블릿 내부에 맴버 변수를 설정하지말고 사용하자!

가령, 위의 서블릿 코드에서

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    
    private String userName = ""; 
    
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response){
        // 애플리케이션 로직
        // 요청 내부의 유저 닉네임 유저에 저장
        userName = request.getUserName();
    }
    
    @Override
    protected void service2(HttpServletRequest request, HttpServletResponse response){
        // 애플리케이션 로직
        // userName에 저장된 정보를 response에 담아서 브라우저로 돌려줌 
        response.add(userName);
    }
}
```

이런 코드의 경우 무슨일이 벌어질까?

가령 service() 메서드를 호출하지 않았는데 service2 메서드가 호출된다면 
현재, userName에 A라는 사람의 닉네임이 저장되어있다면, 그 정보를 꺼내서 B라는 사람에게 A의 닉네임을 보여줄수도 있다.

<HR>


#### Q : 위의 상황을 해결하려면?? 

> A : 특정 변수는 맴버로 선언하지말고 함수 내부의 지역변수로 선언해야 한다.

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response){
        // 애플리케이션 로직
        // 요청 내부의 유저 닉네임 유저에 저장
        String userName = "";
        userName = request.getUserName();
        
        // userName에 저장된 정보를 response에 담아서 브라우저로 돌려줌
        response.add(userName);
    }
}
```

즉, 특정 변수의 생명주기가 메서드의 생명주기와 일치해야한다.
문제의 상황에서는 메서드가 끝나고 사라져도 메서드 내부의 정보가 객체 내부에서 살아있는 형태를 띄게되어서 위험하다.




